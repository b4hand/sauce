$$ This is a Pump source file.  Please use Pump to convert it.
$$
$var n = 10  $$ The maximum arity we support.
#ifndef SAUCE_INTERNAL_NEW_BINDING_H_
#define SAUCE_INTERNAL_NEW_BINDING_H_

#include <sauce/injector.h>
#include <sauce/memory.h>
#include <sauce/named.h>
#include <sauce/provider.h>
#include <sauce/internal/binding.h>
#include <sauce/internal/key.h>
#include <sauce/internal/apply_variadic.h>
#include <sauce/internal/self_injector.h>
#include <sauce/internal/type_id.h>

namespace sauce {
namespace internal {

namespace newschool {

template<typename Dependency, typename Scope, typename Constructor, typename Allocator>
class NewBinding: public Binding<Dependency, Scope> {

  struct ValidateAcyclicParameters {
    template<typename T, int i, typename Passed>
    struct Parameter {
      T yield(Passed) {
        return T(); // TODO
      }
    };
  };

  struct ProvideParameters {
    template<typename T, int i, typename Passed>
    struct Parameter {
      T yield(Passed) {
        return T(); // TODO
      }
    };
  };

  typedef ApplyConstructor<ValidateAcyclicParameters, Constructor, Allocator> ValidateAcyclic;
  typedef ApplyConstructor<ProvideParameters, Constructor, Allocator> Provide;
  typedef typename Provide::Constructed Impl;
  typedef typename Key<Dependency>::Iface Iface;
  typedef typename Key<Dependency>::Ptr IfacePtr;
  typedef sauce::shared_ptr<Impl> ImplPtr;
  typedef NewBinding<Dependency, Scope, Constructor, Allocator> New;
  typedef DisposalDeleter<Iface, New> Deleter;

  std::vector<std::string> dynamicDependencyNames;

  void validateAcyclic(InjectorPtr injector, TypeIds & ids) const {
    // TODO
  }

  void setDynamicDependencyNames(std::vector<std::string> const & dynamicDependencyNames) {
    // TODO
  }

public:

  typedef typename ResolvedBinding<Dependency>::BindingPtr BindingPtr;

  NewBinding():
    dynamicDependencyNames(0 /* TODO */, unnamed()) {}

  /**
   * Provide an Iface.
   *
   * A naked instance pointer is allocated and wrapped in a shared_ptr.  It is
   * also given a custom deleter, to dispose of the naked pointer with
   * dispose(Iface *).
   */
  IfacePtr provide(BindingPtr binding, InjectorPtr injector) const {
    IfacePtr TODO;
    return TODO;
  }

  void dispose(Iface * iface) const {
    Impl * impl = static_cast<Impl *>(iface);
    impl->~Impl(); // Must not throw
    // allocator.deallocate(impl, 1); // TODO
  }

};

}

namespace oldschool {

$range includeParens 0..1
$for includeParens [[
$var parens = [[$if includeParens==1 [[()]]]]
$var specializationParameters = [[$if includeParens==1 [[<Dependency, Scope, Impl(), Allocator>]]]]

/* *INDENT-OFF* */
template<typename Dependency, typename Scope, typename Impl, typename Allocator>
class NewBinding$specializationParameters: public Binding<Dependency, Scope> {

  typedef typename Key<Dependency>::Iface Iface;
  typedef typename Key<Dependency>::Ptr IfacePtr;
  typedef sauce::shared_ptr<Impl> ImplPtr;
  typedef typename Allocator::template rebind<Impl>::other ImplAllocator;
  typedef NewBinding<Dependency, Scope, Impl$parens, Allocator> New;
  typedef DisposalDeleter<Iface, New> Deleter;

  friend class DisposalDeleter<Iface, New>;

  mutable ImplAllocator allocator;

  void validateAcyclic(InjectorPtr, TypeIds &) const {}

  void setDynamicDependencyNames(std::vector<std::string> const &) {}

public:

  typedef typename ResolvedBinding<Dependency>::BindingPtr BindingPtr;

  NewBinding():
    allocator() {}

  /**
   * Provide an Iface.
   *
   * A naked instance pointer is allocated and wrapped in a shared_ptr.  It is
   * also given a custom deleter, to dispose of the naked pointer with
   * dispose(Iface *).
   */
  IfacePtr provide(BindingPtr binding, InjectorPtr) const {
    Deleter deleter(sauce::static_pointer_cast<New>(binding));
    ImplPtr impl(new(allocator.allocate(1)) Impl(), deleter);
    SelfInjector<Impl> selfInjector;
    selfInjector.setSelf(impl);
    return sauce::static_pointer_cast<Iface>(impl);
  }

  void dispose(Iface * iface) const {
    Impl * impl = static_cast<Impl *>(iface);
    impl->~Impl(); // Must not throw
    allocator.deallocate(impl, 1);
  }
};
/* *INDENT-ON* */

]]

$range i 1..n
$for i [[
$range j 1..i
$var comma_typename_As = [[$for j [[, typename A$j]]]]
$var As = [[$for j, [[A$j]]]]
$var as = [[$for j, [[a$j]]]]

/* *INDENT-OFF* */
template<typename Dependency, typename Scope, typename Impl, typename Allocator$comma_typename_As>
class NewBinding<Dependency, Scope, Impl($As), Allocator>: public Binding<Dependency, Scope> {

  // TODO Ditch this, but instantiate the template for now
  typedef i::newschool::NewBinding<Dependency, Scope, Impl($As), Allocator> NewWorld;

  typedef typename Key<Dependency>::Iface Iface;
  typedef typename Key<Dependency>::Ptr IfacePtr;
  typedef sauce::shared_ptr<Impl> ImplPtr;
  typedef typename Allocator::template rebind<Impl>::other ImplAllocator;
  typedef NewBinding<Dependency, Scope, Impl($As), Allocator> New;
  typedef DisposalDeleter<Iface, New> Deleter;

  friend class DisposalDeleter<Iface, New>;

  mutable ImplAllocator allocator;
  std::vector<std::string> dynamicDependencyNames;

  void validateAcyclic(InjectorPtr injector, TypeIds & ids) const {
[[$for j [[
    this->template validateAcyclicHelper<A$j>(injector, ids, dynamicDependencyNames[$(j-1)]);

]]]]
  }

  void setDynamicDependencyNames(std::vector<std::string> const & dynamicDependencyNames) {
    this->dynamicDependencyNames = dynamicDependencyNames;
    this->dynamicDependencyNames.resize($i, unnamed());
  }

public:

  typedef typename ResolvedBinding<Dependency>::BindingPtr BindingPtr;

  NewBinding():
    allocator(),
    dynamicDependencyNames($i, unnamed()) {}

  /**
   * Provide an Iface.
   *
   * A naked instance pointer is allocated and wrapped in a shared_ptr.  It is
   * also given a custom deleter, to dispose of the naked pointer with
   * dispose(Iface *).
   */
  IfacePtr provide(BindingPtr binding, InjectorPtr injector) const {
[[$for j [[
    typename Key<A$j>::Ptr a$j(this->template getHelper<typename i::Key<A$j>::Normalized>(injector, dynamicDependencyNames[$(j-1)]));

]]]]
    Deleter deleter(sauce::static_pointer_cast<New>(binding));
    ImplPtr impl(new(allocator.allocate(1)) Impl($as), deleter);
    SelfInjector<Impl> selfInjector;
    selfInjector.setSelf(impl);
    return sauce::static_pointer_cast<Iface>(impl);
  }

  void dispose(Iface * iface) const {
    Impl * impl = static_cast<Impl *>(iface);
    impl->~Impl(); // Must not throw
    allocator.deallocate(impl, 1);
  }
};
/* *INDENT-ON* */

]]

}

using namespace oldschool;
// using namespace newschool;

}

namespace i = ::sauce::internal;

}

#endif // SAUCE_INTERNAL_NEW_BINDING_H_
