$$ This is a Pump source file.  Please use Pump to convert it.
$$
$var n = 10  $$ The maximum arity we support.
#ifndef SAUCE_INTERNAL_NEW_BINDING_H_
#define SAUCE_INTERNAL_NEW_BINDING_H_

#include <sauce/injector.h>
#include <sauce/memory.h>
#include <sauce/named.h>
#include <sauce/provider.h>
#include <sauce/internal/binding.h>
#include <sauce/internal/key.h>
#include <sauce/internal/apply_variadic.h>
#include <sauce/internal/self_injector.h>
#include <sauce/internal/type_id.h>

namespace sauce {
namespace internal {

namespace newschool {

template<typename Dependency, typename Scope, typename Constructor, typename Allocator>
class NewBinding: public Binding<Dependency, Scope> {

  typedef NewBinding<Dependency, Scope, Constructor, Allocator> New;

  /**
   * A mixin for ApplyVariadic parameter concept types.
   */
  struct NewBindingFriend {
    template<typename T>
    void validateAcyclicHelper(New & binding, InjectorPtr injector, TypeIds & ids, std::string dependencyName) {
      binding->template validateAcyclicHelper<T>(injector, ids, dependencyName);
    }
  };

  friend class NewBindingFriend;

  struct ProvideParameters {
    template<typename T, int i, typename Passed>
    struct Parameter: public NewBindingFriend {
      T yield(Passed) {
        return T(); // TODO
      }
    };
  };

  typedef ApplyConstructor<ProvideParameters, Constructor, Allocator> Provide;
  typedef typename Provide::Constructed Impl;
  typedef typename Key<Dependency>::Iface Iface;
  typedef typename Key<Dependency>::Ptr IfacePtr;
  typedef sauce::shared_ptr<Impl> ImplPtr;
  typedef DisposalDeleter<Iface, New> Deleter;

  std::vector<std::string> dynamicDependencyNames;

  struct ValidateAcyclicParameters {
    struct Passed {
      New & binding;
      InjectorPtr & injector;
      TypeIds & ids;

      Passed(New & binding, InjectorPtr & injector, TypeIds & ids):
        binding(binding), injector(injector), ids(ids) {}
    };
    
    template<typename T, int i>
    struct Parameter: public NewBindingFriend {
      void observe(Passed & passed) {
        New & binding = passed.binding;
        InjectorPtr & injector = passed.injector;
        TypeIds & ids = passed.ids;
        std::string dependencyName = binding.dynamicDependencyNames[i];

        this->template validateAcyclicHelper<T>(binding, injector, ids, dependencyName);
      }
    };
  };

  void validateAcyclic(InjectorPtr injector, TypeIds & ids) const {
    typename ValidateAcyclicParameters::Passed passed(*this, injector, ids);
    observeConstructor<ValidateAcyclicParameters, Constructor, Allocator>(passed);
  }

  void setDynamicDependencyNames(std::vector<std::string> const & dynamicDependencyNames) {
    this->dynamicDependencyNames = dynamicDependencyNames;
    this->dynamicDependencyNames.resize(Provide::arity(), unnamed());
  }

public:

  typedef typename ResolvedBinding<Dependency>::BindingPtr BindingPtr;

  NewBinding():
    dynamicDependencyNames(Provide::arity(), unnamed()) {}

  /**
   * Provide an Iface.
   *
   * A naked instance pointer is allocated and wrapped in a shared_ptr.  It is
   * also given a custom deleter, to dispose of the naked pointer with
   * dispose(Iface *).
   */
  IfacePtr provide(BindingPtr binding, InjectorPtr injector) const {
    IfacePtr TODO;
    return TODO;
  }

  void dispose(Iface * iface) const {
    Impl * impl = static_cast<Impl *>(iface);
    impl->~Impl(); // Must not throw
    // allocator.deallocate(impl, 1); // TODO
  }

};

}

namespace oldschool {

$range includeParens 0..1
$for includeParens [[
$var parens = [[$if includeParens==1 [[()]]]]
$var specializationParameters = [[$if includeParens==1 [[<Dependency, Scope, Impl(), Allocator>]]]]

/* *INDENT-OFF* */
template<typename Dependency, typename Scope, typename Impl, typename Allocator>
class NewBinding$specializationParameters: public Binding<Dependency, Scope> {

  typedef typename Key<Dependency>::Iface Iface;
  typedef typename Key<Dependency>::Ptr IfacePtr;
  typedef sauce::shared_ptr<Impl> ImplPtr;
  typedef typename Allocator::template rebind<Impl>::other ImplAllocator;
  typedef NewBinding<Dependency, Scope, Impl$parens, Allocator> New;
  typedef DisposalDeleter<Iface, New> Deleter;

  friend class DisposalDeleter<Iface, New>;

  mutable ImplAllocator allocator;

  void validateAcyclic(InjectorPtr, TypeIds &) const {}

  void setDynamicDependencyNames(std::vector<std::string> const &) {}

public:

  typedef typename ResolvedBinding<Dependency>::BindingPtr BindingPtr;

  NewBinding():
    allocator() {}

  /**
   * Provide an Iface.
   *
   * A naked instance pointer is allocated and wrapped in a shared_ptr.  It is
   * also given a custom deleter, to dispose of the naked pointer with
   * dispose(Iface *).
   */
  IfacePtr provide(BindingPtr binding, InjectorPtr) const {
    Deleter deleter(sauce::static_pointer_cast<New>(binding));
    ImplPtr impl(new(allocator.allocate(1)) Impl(), deleter);
    SelfInjector<Impl> selfInjector;
    selfInjector.setSelf(impl);
    return sauce::static_pointer_cast<Iface>(impl);
  }

  void dispose(Iface * iface) const {
    Impl * impl = static_cast<Impl *>(iface);
    impl->~Impl(); // Must not throw
    allocator.deallocate(impl, 1);
  }
};
/* *INDENT-ON* */

]]

$range i 1..n
$for i [[
$range j 1..i
$var comma_typename_As = [[$for j [[, typename A$j]]]]
$var As = [[$for j, [[A$j]]]]
$var as = [[$for j, [[a$j]]]]

/* *INDENT-OFF* */
template<typename Dependency, typename Scope, typename Impl, typename Allocator$comma_typename_As>
class NewBinding<Dependency, Scope, Impl($As), Allocator>: public Binding<Dependency, Scope> {

  // TODO Ditch this, but instantiate the template for now
  typedef i::newschool::NewBinding<Dependency, Scope, Impl($As), Allocator> NewWorld;

  typedef typename Key<Dependency>::Iface Iface;
  typedef typename Key<Dependency>::Ptr IfacePtr;
  typedef sauce::shared_ptr<Impl> ImplPtr;
  typedef typename Allocator::template rebind<Impl>::other ImplAllocator;
  typedef NewBinding<Dependency, Scope, Impl($As), Allocator> New;
  typedef DisposalDeleter<Iface, New> Deleter;

  friend class DisposalDeleter<Iface, New>;

  mutable ImplAllocator allocator;
  std::vector<std::string> dynamicDependencyNames;

  void validateAcyclic(InjectorPtr injector, TypeIds & ids) const {
[[$for j [[
    this->template validateAcyclicHelper<A$j>(injector, ids, dynamicDependencyNames[$(j-1)]);

]]]]
  }

  void setDynamicDependencyNames(std::vector<std::string> const & dynamicDependencyNames) {
    this->dynamicDependencyNames = dynamicDependencyNames;
    this->dynamicDependencyNames.resize($i, unnamed());
  }

public:

  typedef typename ResolvedBinding<Dependency>::BindingPtr BindingPtr;

  NewBinding():
    allocator(),
    dynamicDependencyNames($i, unnamed()) {}

  /**
   * Provide an Iface.
   *
   * A naked instance pointer is allocated and wrapped in a shared_ptr.  It is
   * also given a custom deleter, to dispose of the naked pointer with
   * dispose(Iface *).
   */
  IfacePtr provide(BindingPtr binding, InjectorPtr injector) const {
[[$for j [[
    typename Key<A$j>::Ptr a$j(this->template getHelper<typename i::Key<A$j>::Normalized>(injector, dynamicDependencyNames[$(j-1)]));

]]]]
    Deleter deleter(sauce::static_pointer_cast<New>(binding));
    ImplPtr impl(new(allocator.allocate(1)) Impl($as), deleter);
    SelfInjector<Impl> selfInjector;
    selfInjector.setSelf(impl);
    return sauce::static_pointer_cast<Iface>(impl);
  }

  void dispose(Iface * iface) const {
    Impl * impl = static_cast<Impl *>(iface);
    impl->~Impl(); // Must not throw
    allocator.deallocate(impl, 1);
  }
};
/* *INDENT-ON* */

]]

}

using namespace oldschool;
// using namespace newschool;

}

namespace i = ::sauce::internal;

}

#endif // SAUCE_INTERNAL_NEW_BINDING_H_
