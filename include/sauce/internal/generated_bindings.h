// This file was GENERATED by command:
//     pump.py generated_bindings.h.pump
// DO NOT EDIT BY HAND!!!

#ifndef SAUCE_SAUCE_INTERNAL_GENERATED_BINDINGS_H_
#define SAUCE_SAUCE_INTERNAL_GENERATED_BINDINGS_H_

#include <sauce/internal/injection_cache.h>

namespace sauce { namespace internal { namespace bindings {

  template<typename Injector>
  class Binding;

  template<typename Injector, typename Iface, typename Constructor>
  class New;

  template<typename Injector, typename Iface, typename Impl>
  class New<Injector, Iface, Impl()>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {

      Impl * provided = new_delete(injector).template _new<Impl>();
      InjectionCache<Injector, Iface *()>::insert(injector, provided);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *()>::dispose(injector, iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1>
  class New<Injector, Iface, Impl(A1)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());

      Impl * provided = new_delete(injector).template _new<Impl, A1>(a1);
      InjectionCache<Injector, Iface *(A1)>::insert(injector, provided, a1);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1)>::dispose(injector, iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1,
      typename A2>
  class New<Injector, Iface, Impl(A1, A2)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());
      A2 a2(injector.template provide<A2>());

      Impl * provided = new_delete(injector).template _new<Impl, A1, A2>(a1,
          a2);
      InjectionCache<Injector, Iface *(A1, A2)>::insert(injector, provided, a1,
          a2);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1, A2)>::dispose(injector, iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1,
      typename A2, typename A3>
  class New<Injector, Iface, Impl(A1, A2, A3)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());
      A2 a2(injector.template provide<A2>());
      A3 a3(injector.template provide<A3>());

      Impl * provided = new_delete(injector).template _new<Impl, A1, A2,
          A3>(a1, a2, a3);
      InjectionCache<Injector, Iface *(A1, A2, A3)>::insert(injector, provided,
          a1, a2, a3);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1, A2, A3)>::dispose(injector, iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1,
      typename A2, typename A3, typename A4>
  class New<Injector, Iface, Impl(A1, A2, A3, A4)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());
      A2 a2(injector.template provide<A2>());
      A3 a3(injector.template provide<A3>());
      A4 a4(injector.template provide<A4>());

      Impl * provided = new_delete(injector).template _new<Impl, A1, A2, A3,
          A4>(a1, a2, a3, a4);
      InjectionCache<Injector, Iface *(A1, A2, A3, A4)>::insert(injector,
          provided, a1, a2, a3, a4);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1, A2, A3, A4)>::dispose(injector,
          iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1,
      typename A2, typename A3, typename A4, typename A5>
  class New<Injector, Iface, Impl(A1, A2, A3, A4,
      A5)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());
      A2 a2(injector.template provide<A2>());
      A3 a3(injector.template provide<A3>());
      A4 a4(injector.template provide<A4>());
      A5 a5(injector.template provide<A5>());

      Impl * provided = new_delete(injector).template _new<Impl, A1, A2, A3,
          A4, A5>(a1, a2, a3, a4, a5);
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5)>::insert(injector,
          provided, a1, a2, a3, a4, a5);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5)>::dispose(injector,
          iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1,
      typename A2, typename A3, typename A4, typename A5, typename A6>
  class New<Injector, Iface, Impl(A1, A2, A3, A4, A5,
      A6)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());
      A2 a2(injector.template provide<A2>());
      A3 a3(injector.template provide<A3>());
      A4 a4(injector.template provide<A4>());
      A5 a5(injector.template provide<A5>());
      A6 a6(injector.template provide<A6>());

      Impl * provided = new_delete(injector).template _new<Impl, A1, A2, A3,
          A4, A5, A6>(a1, a2, a3, a4, a5, a6);
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5,
          A6)>::insert(injector, provided, a1, a2, a3, a4, a5, a6);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5,
          A6)>::dispose(injector, iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1,
      typename A2, typename A3, typename A4, typename A5, typename A6,
      typename A7>
  class New<Injector, Iface, Impl(A1, A2, A3, A4, A5, A6,
      A7)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());
      A2 a2(injector.template provide<A2>());
      A3 a3(injector.template provide<A3>());
      A4 a4(injector.template provide<A4>());
      A5 a5(injector.template provide<A5>());
      A6 a6(injector.template provide<A6>());
      A7 a7(injector.template provide<A7>());

      Impl * provided = new_delete(injector).template _new<Impl, A1, A2, A3,
          A4, A5, A6, A7>(a1, a2, a3, a4, a5, a6, a7);
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5, A6,
          A7)>::insert(injector, provided, a1, a2, a3, a4, a5, a6, a7);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5, A6,
          A7)>::dispose(injector, iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1,
      typename A2, typename A3, typename A4, typename A5, typename A6,
      typename A7, typename A8>
  class New<Injector, Iface, Impl(A1, A2, A3, A4, A5, A6, A7,
      A8)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());
      A2 a2(injector.template provide<A2>());
      A3 a3(injector.template provide<A3>());
      A4 a4(injector.template provide<A4>());
      A5 a5(injector.template provide<A5>());
      A6 a6(injector.template provide<A6>());
      A7 a7(injector.template provide<A7>());
      A8 a8(injector.template provide<A8>());

      Impl * provided = new_delete(injector).template _new<Impl, A1, A2, A3,
          A4, A5, A6, A7, A8>(a1, a2, a3, a4, a5, a6, a7, a8);
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5, A6, A7,
          A8)>::insert(injector, provided, a1, a2, a3, a4, a5, a6, a7, a8);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5, A6, A7,
          A8)>::dispose(injector, iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1,
      typename A2, typename A3, typename A4, typename A5, typename A6,
      typename A7, typename A8, typename A9>
  class New<Injector, Iface, Impl(A1, A2, A3, A4, A5, A6, A7, A8,
      A9)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());
      A2 a2(injector.template provide<A2>());
      A3 a3(injector.template provide<A3>());
      A4 a4(injector.template provide<A4>());
      A5 a5(injector.template provide<A5>());
      A6 a6(injector.template provide<A6>());
      A7 a7(injector.template provide<A7>());
      A8 a8(injector.template provide<A8>());
      A9 a9(injector.template provide<A9>());

      Impl * provided = new_delete(injector).template _new<Impl, A1, A2, A3,
          A4, A5, A6, A7, A8, A9>(a1, a2, a3, a4, a5, a6, a7, a8, a9);
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5, A6, A7, A8,
          A9)>::insert(injector, provided, a1, a2, a3, a4, a5, a6, a7, a8, a9);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5, A6, A7, A8,
          A9)>::dispose(injector, iface);
    }
  };

  template<typename Injector, typename Iface, typename Impl, typename A1,
      typename A2, typename A3, typename A4, typename A5, typename A6,
      typename A7, typename A8, typename A9, typename A10>
  class New<Injector, Iface, Impl(A1, A2, A3, A4, A5, A6, A7, A8, A9,
      A10)>: public Binding<Injector> {
  public:
    static Impl * provide(Injector & injector) {
      A1 a1(injector.template provide<A1>());
      A2 a2(injector.template provide<A2>());
      A3 a3(injector.template provide<A3>());
      A4 a4(injector.template provide<A4>());
      A5 a5(injector.template provide<A5>());
      A6 a6(injector.template provide<A6>());
      A7 a7(injector.template provide<A7>());
      A8 a8(injector.template provide<A8>());
      A9 a9(injector.template provide<A9>());
      A10 a10(injector.template provide<A10>());

      Impl * provided = new_delete(injector).template _new<Impl, A1, A2, A3,
          A4, A5, A6, A7, A8, A9, A10>(a1, a2, a3, a4, a5, a6, a7, a8, a9,
          a10);
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5, A6, A7, A8, A9,
          A10)>::insert(injector, provided, a1, a2, a3, a4, a5, a6, a7, a8, a9,
          a10);
      return provided;
    }

    static void dispose(Injector & injector, Iface * iface) {
      new_delete(injector)._delete(iface);
      // TODO: thread safety would require us to first fetch the injection
      // cache entry, then dispose the dependent, then dispose the injected
      // dependencies.  The issue is that our deleted pointer is eligible for
      // reuse, and may potentially be reinserted into our cache before we
      // remove the old entry.
      InjectionCache<Injector, Iface *(A1, A2, A3, A4, A5, A6, A7, A8, A9,
          A10)>::dispose(injector, iface);
    }
  };

} } } // namespace bindings, namespace internal, namespace sauce

#endif
