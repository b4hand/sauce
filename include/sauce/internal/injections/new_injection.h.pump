$$ This is a Pump source file.  Please use Pump to convert it to new.h
$$
$var n = 10  $$ The maximum arity we support.
#ifndef SAUCE_INTERNAL_INJECTIONS_NEW_INJECTION_H_
#define SAUCE_INTERNAL_INJECTIONS_NEW_INJECTION_H_

#include <sauce/injector.h>
#include <sauce/memory.h>
#include <sauce/named.h>
#include <sauce/provider.h>
#include <sauce/internal/resolved_binding.h>
#include <sauce/internal/injections/injection.h>
#include <sauce/internal/key.h>
#include <sauce/internal/type_id.h>

namespace sauce {
namespace internal {
namespace injections {

template<typename Dependency, typename Scope, typename Constructor, typename Allocator>
class NewInjection;

$range i 0..n
$for i [[
$range j 1..i
$var comma_typename_As = [[$for j [[, typename A$j]]]]
$var As = [[$for j, [[A$j]]]]
$var as = [[$for j, [[a$j]]]]

template<typename Dependency, typename Scope, typename Impl, typename Allocator$comma_typename_As>
class NewInjection<Dependency, Scope, Impl($As), Allocator>:
  public Injection<Dependency> {

  typedef typename Key<Dependency>::Iface Iface;
  typedef typename Key<Dependency>::Ptr Ptr;
  typedef typename ResolvedBinding<Dependency>::BindingPtr BindingPtr;
  typedef typename Allocator::template rebind<Impl>::other ImplAllocator;
  typedef NewInjection<Dependency, Scope, Impl($As), Allocator> New;
  typedef DisposalDeleter<Iface, New> Deleter;

  friend class DisposalDeleter<Iface, New>;

  mutable ImplAllocator allocator;

  /**
   * Provide an Iface.
   *
   * A naked instance pointer is allocated and wrapped in a shared_ptr.  It is
   * also given a custom deleter, to dispose of the naked pointer with
   * dispose(Iface *).
   */
[[$if i==0 [[
 Ptr provide(BindingPtr binding, InjectorPtr) const
]] $else [[
 Ptr provide(BindingPtr binding, InjectorPtr injector) const
]]]] {
[[$for j [[
    typename Key<A$j>::Ptr a$j(this->template getHelper<A$j>(injector));

]]]]
    Deleter deleter(sauce::static_pointer_cast<New>(binding));
    Impl * impl = allocator.allocate(1);
    Ptr provided(new(impl) Impl($as), deleter);
    return provided;
  }
[[$if i>0 [[

  void validateAcyclic(InjectorPtr injector, TypeIds & ids) const {
[[$for j [[
    this->template validateAcyclicHelper<A$j>(injector, ids);

]]]]
  }

]]]]

  void dispose(Iface * iface) const {
    Impl * impl = static_cast<Impl *>(iface);
    impl->~Impl(); // Must not throw
    allocator.deallocate(impl, 1);
  }

  TypeId getScopeKey() const {
    return typeIdOf<Scope>();
  }
};

]]

}
}

namespace i = ::sauce::internal;
namespace inj = ::sauce::internal::injections;

}

#endif // SAUCE_INTERNAL_INJECTIONS_NEW_INJECTION_H_
