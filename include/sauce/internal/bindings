// This file was GENERATED by command:
//     pump.py bindings.pump
// DO NOT EDIT BY HAND!!!

// -*- C++ -*-
#ifndef SAUCE_SAUCE_INTERNAL_BINDINGS_H_
#define SAUCE_SAUCE_INTERNAL_BINDINGS_H_

#include <sauce/memory>

namespace sauce {
namespace internal {
namespace bindings {

template<typename Injector, typename Iface, typename Allocator,
    typename Constructor>
class New;

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_>
class New<Injector_, Iface_, Allocator_, Impl_()> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl();
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1>
class New<Injector_, Iface_, Allocator_, Impl_(A1)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1, typename A2>
class New<Injector_, Iface_, Allocator_, Impl_(A1, A2)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    SAUCE_SHARED_PTR<A2> a2(injector.template get<A2>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1, a2);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1, typename A2, typename A3>
class New<Injector_, Iface_, Allocator_, Impl_(A1, A2, A3)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    SAUCE_SHARED_PTR<A2> a2(injector.template get<A2>());
    SAUCE_SHARED_PTR<A3> a3(injector.template get<A3>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1, a2, a3);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1, typename A2, typename A3, typename A4>
class New<Injector_, Iface_, Allocator_, Impl_(A1, A2, A3, A4)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    SAUCE_SHARED_PTR<A2> a2(injector.template get<A2>());
    SAUCE_SHARED_PTR<A3> a3(injector.template get<A3>());
    SAUCE_SHARED_PTR<A4> a4(injector.template get<A4>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1, a2, a3, a4);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1, typename A2, typename A3, typename A4,
    typename A5>
class New<Injector_, Iface_, Allocator_, Impl_(A1, A2, A3, A4, A5)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    SAUCE_SHARED_PTR<A2> a2(injector.template get<A2>());
    SAUCE_SHARED_PTR<A3> a3(injector.template get<A3>());
    SAUCE_SHARED_PTR<A4> a4(injector.template get<A4>());
    SAUCE_SHARED_PTR<A5> a5(injector.template get<A5>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1, a2, a3, a4, a5);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6>
class New<Injector_, Iface_, Allocator_, Impl_(A1, A2, A3, A4, A5, A6)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    SAUCE_SHARED_PTR<A2> a2(injector.template get<A2>());
    SAUCE_SHARED_PTR<A3> a3(injector.template get<A3>());
    SAUCE_SHARED_PTR<A4> a4(injector.template get<A4>());
    SAUCE_SHARED_PTR<A5> a5(injector.template get<A5>());
    SAUCE_SHARED_PTR<A6> a6(injector.template get<A6>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1, a2, a3, a4, a5, a6);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6, typename A7>
class New<Injector_, Iface_, Allocator_, Impl_(A1, A2, A3, A4, A5, A6, A7)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    SAUCE_SHARED_PTR<A2> a2(injector.template get<A2>());
    SAUCE_SHARED_PTR<A3> a3(injector.template get<A3>());
    SAUCE_SHARED_PTR<A4> a4(injector.template get<A4>());
    SAUCE_SHARED_PTR<A5> a5(injector.template get<A5>());
    SAUCE_SHARED_PTR<A6> a6(injector.template get<A6>());
    SAUCE_SHARED_PTR<A7> a7(injector.template get<A7>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1, a2, a3, a4, a5, a6, a7);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6, typename A7, typename A8>
class New<Injector_, Iface_, Allocator_, Impl_(A1, A2, A3, A4, A5, A6, A7,
    A8)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    SAUCE_SHARED_PTR<A2> a2(injector.template get<A2>());
    SAUCE_SHARED_PTR<A3> a3(injector.template get<A3>());
    SAUCE_SHARED_PTR<A4> a4(injector.template get<A4>());
    SAUCE_SHARED_PTR<A5> a5(injector.template get<A5>());
    SAUCE_SHARED_PTR<A6> a6(injector.template get<A6>());
    SAUCE_SHARED_PTR<A7> a7(injector.template get<A7>());
    SAUCE_SHARED_PTR<A8> a8(injector.template get<A8>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1, a2, a3, a4, a5, a6, a7, a8);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6, typename A7, typename A8, typename A9>
class New<Injector_, Iface_, Allocator_, Impl_(A1, A2, A3, A4, A5, A6, A7, A8,
    A9)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    SAUCE_SHARED_PTR<A2> a2(injector.template get<A2>());
    SAUCE_SHARED_PTR<A3> a3(injector.template get<A3>());
    SAUCE_SHARED_PTR<A4> a4(injector.template get<A4>());
    SAUCE_SHARED_PTR<A5> a5(injector.template get<A5>());
    SAUCE_SHARED_PTR<A6> a6(injector.template get<A6>());
    SAUCE_SHARED_PTR<A7> a7(injector.template get<A7>());
    SAUCE_SHARED_PTR<A8> a8(injector.template get<A8>());
    SAUCE_SHARED_PTR<A9> a9(injector.template get<A9>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1, a2, a3, a4, a5, a6, a7, a8, a9);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

template<typename Injector_, typename Iface_, typename Allocator_,
    typename Impl_, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6, typename A7, typename A8, typename A9,
    typename A10>
class New<Injector_, Iface_, Allocator_, Impl_(A1, A2, A3, A4, A5, A6, A7, A8,
    A9, A10)> {
public:
  typedef Iface_ Iface;
  typedef Impl_ Impl;
  typedef Allocator_ ImplAllocator;
  typedef typename ImplAllocator::pointer ImplPointer;
  typedef typename Allocator_::template rebind<Iface>::other IfaceAllocator;
  typedef typename IfaceAllocator::pointer IfacePointer;
  typedef void Disposer(Injector_ const &, IfacePointer);

  static ImplPointer provide(Injector_ const & injector) {
    SAUCE_SHARED_PTR<A1> a1(injector.template get<A1>());
    SAUCE_SHARED_PTR<A2> a2(injector.template get<A2>());
    SAUCE_SHARED_PTR<A3> a3(injector.template get<A3>());
    SAUCE_SHARED_PTR<A4> a4(injector.template get<A4>());
    SAUCE_SHARED_PTR<A5> a5(injector.template get<A5>());
    SAUCE_SHARED_PTR<A6> a6(injector.template get<A6>());
    SAUCE_SHARED_PTR<A7> a7(injector.template get<A7>());
    SAUCE_SHARED_PTR<A8> a8(injector.template get<A8>());
    SAUCE_SHARED_PTR<A9> a9(injector.template get<A9>());
    SAUCE_SHARED_PTR<A10> a10(injector.template get<A10>());
    ImplAllocator allocator;
    ImplPointer impl = allocator.allocate(1);
    new(impl) Impl(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    return impl;
  }

  static void dispose(Injector_ const & injector, IfacePointer iface) {
    ImplAllocator allocator;
    ImplPointer impl = static_cast<ImplPointer>(iface);
    impl->~Impl();
    allocator.deallocate(impl, 1);
  }
};

}
}
}

#endif // SAUCE_SAUCE_INTERNAL_BINDINGS_H_
