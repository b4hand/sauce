$$ This is a Pump source file.  Please use Pump to convert it to new.h
$$
$var n = 10  $$ The maximum arity we support.
#ifndef SAUCE_SAUCE_INTERNAL_BINDINGS_NEW_BINDING_H_
#define SAUCE_SAUCE_INTERNAL_BINDINGS_NEW_BINDING_H_

#include <sauce/injector.h>
#include <sauce/memory.h>
#include <sauce/named.h>
#include <sauce/provider.h>
#include <sauce/internal/binding.h>
#include <sauce/internal/bindings/naked_binding.h>
#include <sauce/internal/bindings/transparent_binding.h>
#include <sauce/internal/key.h>
#include <sauce/internal/type_id.h>

namespace sauce {
namespace internal {
namespace bindings {

template<typename Dependency, typename Scope, typename Constructor, typename Allocator>
class NewBinding;

template<typename Dependency, typename Constructor, typename Allocator>
class NewProvider;

$range i 0..n
$for i [[
$range j 1..i
$var comma_typename_As = [[$for j [[, typename A$j]]]]
$var As = [[$for j, [[A$j]]]]
$var as = [[$for j, [[a$j]]]]

template<typename Dependency, typename Impl, typename Allocator$comma_typename_As>
class NewProvider<Dependency, Impl($As), Allocator>: NakedProvider<Dependency> {
  typedef typename Key<Dependency>::Iface Iface;
  typedef typename Allocator::template rebind<Impl>::other ImplAllocator;
[[$if i>0 [[

[[$for j [[
  typename Key<Provider<A$j> >::Ptr provider$j;

]]]]

  NewProvider([[$for j, [[
typename Key<Provider<A$j> >::Ptr provider$j
]]]]):
    NakedProvider<Dependency>()[[$for j [[,
    provider$j(provider$j)
]]]] {}
]]]]

  Iface * provide() {
[[$for j [[
    typename Key<A$j>::Ptr a$j = provider$j->get();

]]]]
    ImplAllocator allocator;
    Impl * impl = allocator.allocate(1);
    new(impl) Impl($as);
    return impl;
  }

  void dispose(Iface * iface) {
    Impl * impl = static_cast<Impl *>(iface);
    ImplAllocator allocator;
    impl->~Impl(); // Must not throw
    allocator.deallocate(impl, 1);
  }
};

template<typename Dependency, typename Scope, typename Impl, typename Allocator$comma_typename_As>
struct NewBinding<Dependency, Scope, Impl($As), Allocator>: public NakedBinding<Dependency, Scope> {
  typedef typename Key<Dependency>::Iface Iface;
  typedef typename Allocator::template rebind<Impl>::other ImplAllocator;

[[$if i==0 [[
  void validateAcyclic(sauce::shared_ptr<Injector>, TypeIds &) const {}
]] $else [[
  void validateAcyclic(sauce::shared_ptr<Injector> injector, TypeIds & ids) const {
[[$for j [[
    this->template validateAcyclicos<A$j>(injector, ids);

]]]]
  }
]]]]


[[$if i==0 [[
  Iface * provide(sauce::shared_ptr<Injector>) const
]] $else [[
  Iface * provide(sauce::shared_ptr<Injector> injector) const
]]]]
 {
[[$for j [[
    typename Key<A$j>::Ptr a$j(this->template getDependency<A$j>(injector));

]]]]
    ImplAllocator allocator;
    Impl * impl = allocator.allocate(1);
    new(impl) Impl($as);
    return impl;
  }

  void dispose(Iface * iface) const {
    Impl * impl = static_cast<Impl *>(iface);
    ImplAllocator allocator;
    impl->~Impl(); // Must not throw
    allocator.deallocate(impl, 1);
  }
};

]]

}
}

namespace i = ::sauce::internal;
namespace b = ::sauce::internal::bindings;

}

#endif // SAUCE_SAUCE_INTERNAL_BINDINGS_NEW_BINDING_H_
